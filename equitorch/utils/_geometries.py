import e3nn.math
import torch
from torch import Tensor
from typing import Optional
from torch_geometric.utils import scatter, segment
import e3nn
import e3nn.o3 as o3

from ..math._o3 import wigner_D, xyz_to_angles


from ._indices import check_degree_range, degrees_in_range

from ..typing import DegreeRange

def get_center_of_mass(pos: Tensor, ptr: Tensor, atom_mass: Optional[Tensor] = None):
    r"""Calculate the center of mass for each molecule in a batch.

    Parameters
    ----------
    pos : torch.Tensor
        Tensor of shape (N, 3) containing the positions of all atoms.
    ptr : torch.Tensor
        Tensor containing the cumulative sum of atoms for each molecule in the batch.
    atom_mass : torch.Tensor, optional
        Tensor of shape (N,) containing the mass of each atom. 
        If None, all atoms are assumed to have equal mass.

    Returns
    -------
    torch.Tensor
        Tensor of shape (B, 3) containing the center of mass for each molecule in the batch,
        where B is the number of molecules.
    """

    if atom_mass:
        return segment(pos * atom_mass, ptr) / segment(atom_mass, ptr)
    else:
        return segment(pos, ptr, reduce='mean') 
    
def zero_center_of_mass(pos: Tensor, batch: Tensor, center_of_mass: Tensor):
    r"""Shift the positions of atoms in each molecule so that their center of mass is at the origin.

    Parameters
    ----------
    pos : torch.Tensor
        Tensor of shape (N, 3) containing the positions of all atoms.
    batch : torch.Tensor
        Tensor of shape (N,) indicating which molecule each atom belongs to.
    center_of_mass : torch.Tensor
        Tensor of shape (B, 3) containing the center of mass for each molecule,
        where B is the number of molecules.

    Returns
    -------
    torch.Tensor
        Tensor of shape (N, 3) containing the shifted positions of all atoms.

    Notes
    -----
    This function subtracts the center of mass of each molecule from the positions of its atoms,
    effectively centering each molecule at the origin.
    """
    return pos - center_of_mass.index_select(dim=0, index=batch)

def align_to_z_mat(r: Tensor, need_normalize:bool=True):
    r"""Calculate the rotation matrix R that aligns the vector r with the z-axis.

    Parameters
    ----------
    r : torch.Tensor
        Input vector to be aligned.
    need_normalize : bool, optional
        Whether to normalize the input vector. Default is True.

    Returns
    -------
    torch.Tensor
        Rotation matrix R such that R @ r = z.
    """

    phi, theta = xyz_to_angles(r, need_normalize)
    return o3.matrix_y(-theta) @ o3.matrix_z(-phi)

def edge_align_to_z_mat(pos: Tensor, edge_index: Tensor):
    r"""Calculate the rotation matrix R that aligns the edge vector with the z-axis.

    Parameters
    ----------
    pos : torch.Tensor
        Tensor of node positions.
    edge_index : torch.Tensor
        Tensor of edge indices.

    Returns
    -------
    torch.Tensor
        Rotation matrix R such that R @ r = z, where r is the edge vector.
    """
    to_pos = pos.index_select(dim=-1, index=edge_index[1])
    from_pos = pos.index_select(dim=-1, index=edge_index[0])
    return align_to_z_mat(from_pos - to_pos, need_normalize=True)

def edge_align_to_z_angles(pos: Tensor, edge_index: Tensor):
    r"""Calculate the angles (phi, theta) that describe the rotation to align an edge vector with the z-axis.

    Parameters
    ----------
    pos : torch.Tensor
        Tensor of node positions.
    edge_index : torch.Tensor
        Tensor of edge indices.

    Returns
    -------
    Tuple[torch.Tensor, torch.Tensor]
        A tuple (phi, theta) where:
        - r can be generated by rotating z on y by theta, and then rotating on z by phi.
        - r can be aligned to z by rotating on z by -phi, and then on y by -theta.
    """

    to_pos = pos.index_select(dim=-1, index=edge_index[1])
    from_pos = pos.index_select(dim=-1, index=edge_index[0])
    return xyz_to_angles(from_pos - to_pos, need_normalize=True)

def align_to_z_wigner(r: Tensor, L: DegreeRange, need_normalize:bool=True):
    r"""Returns the Wigner-D matrix corresponding to the return of align_to_z_mat.

    Parameters
    ----------
    r : torch.Tensor
        Input vector to be aligned.
    L : DegreeRange
        Range of degrees for the Wigner-D matrix.
    need_normalize : bool, optional
        Whether to normalize the input vector. Default is True.

    Returns
    -------
    torch.Tensor
        Wigner-D matrix corresponding to the rotation returned by align_to_z_mat.
    """

    L = check_degree_range(L)
    phi, theta = xyz_to_angles(r, need_normalize)
    return wigner_D(L, torch.zeros_like(phi), -theta, -phi).to(r.device)

def edge_align_to_z_wigner(pos: Tensor, edge_index: Tensor, L: DegreeRange):
    r"""Calculate the Wigner-D matrix corresponding to the rotation that aligns an edge vector with the z-axis.

    Parameters
    ----------
    pos : torch.Tensor
        Tensor of node positions.
    edge_index : torch.Tensor
        Tensor of edge indices.
    L : DegreeRange
        Range of degrees for the Wigner-D matrix.

    Returns
    -------
    torch.Tensor
        Wigner-D matrix corresponding to the rotation that aligns the edge vector with the z-axis.
    """
    L = check_degree_range(L)
    phi, theta = edge_align_to_z_angles(pos, edge_index)
    return wigner_D(L, torch.zeros_like(phi), -theta, -phi).to(pos.device)


def rot_on(mat: Tensor, x: Tensor):
    r"""Performs rotation of matrix 'mat' on tensor 'x'.

    This function applies the rotation defined by 'mat' to the tensor 'x'. The behavior
    depends on the dimensions of both 'mat' and 'x'.

    Parameters
    ----------
    mat : torch.Tensor
        The rotation matrix or matrices. Can be 2D, 3D, or 4D.
        - If 2D: A single rotation matrix applied to all samples in x.
        - If 3D: Batched rotation matrices applied sample-wise to x.
        - If 4D: Batched rotation matrices applied both sample-wise and channel-wise to x.
    x : torch.Tensor
        The tensor to be rotated. Can be 2D or 3D.
        - If 2D: Interpreted as a batch of vectors.
        - If 3D: Interpreted as a batch of matrices or multi-channel vectors.

    Returns
    -------
    torch.Tensor
        The rotated tensor. The shape will match the input 'x', except when 'mat'
        is 4D, in which case the channel dimension may change.

    Notes
    -----
    - If x is 2D, it's temporarily expanded to 3D for computation and then squeezed back.
    - The function uses matrix multiplication for 2D and 3D 'mat', and einsum for 4D 'mat'.
    """
    d = x.ndim
    if d == 2:
        x = x.unsqueeze(-1)
    if mat.ndim == 3:
        ret = mat @ x
    elif mat.ndim == 2:
        ret = mat.unsqueeze(0) @ x
    elif mat.ndim == 4:
        ret = torch.einsum('NPQC, NQC -> NPC', mat, x)
    
    if d==2:
        ret = ret.squeeze(-1)

    return ret